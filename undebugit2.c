#include <stdint.h>
/** для lor_contest
	решение а-ля аппаратное на сдвиговом 64-х битном регистре
	забавная идея выравнивать регистр влево позволила не использовать битовые маски и лишние сдвига,
	а сравнивать полный регистр. Наверное в таком стиле можно прооптимизировать вариант wota.
*/	
inline uint8_t *
undebugit2(uint8_t *s) {
	uint8_t *ret;
	int c;
	uint64_t acc=0x2000;	/* а-ля сдвиговый регистр на 8 байт для сравнений, младший байт всегда 00
	                           инициализован пробелом - что любая строка с него начинается
	                        */
	uint64_t the_debug=0x2064656275672000ULL; /* если это (" debug \0") получено в acc - значит есть искомый "debug" */
	ret=s;
    /* начальное заполнение acc с контролем конца строки */
	#define ONESHIFT c=*s++; if (c) acc=(acc|c)<<8; else return ret;
	// ' ' already in acc
	ONESHIFT;//d
	ONESHIFT;//e
	ONESHIFT;//b
	ONESHIFT;//u
	ONESHIFT;//g
	#undef ONESHIFT
    /* регистр частично заполнен - возможно появление искомого слова */
	/* в 2-х случаях "debug "," debug " - можно просто передвинять ret */
	c=*s;
	if(c) {
		acc=(acc|c)<<8;
		/* сравнение *s==0x20 тут и далее можно убрать,
		   оно просто предотвращает лишнее сравнении длинных целых на 32-х битках
		*/
		if (c==0x20 && acc==the_debug) ret=s+1; //memset(s-5,' ',5);
		s++;
	} else goto FINAL;
	c=*s;
	if(c) {
		acc=(acc|c)<<8;
		if (c==0x20 && acc==the_debug) ret=s+1;//memset(s-5,' ',5);
		s++;
	} else goto FINAL;
	/* регистр полностью заполнен - начальное значение вытесненно,
	   в нём только данные из исх.строки, 
	   при совпадении - данные в исх.строке затираются пробелами
	*/
	while((c=*s)!=0) {
		acc=(acc|c)<<8;
		if (c==0x20 && acc==the_debug) {
			/* memset(s-5,' ',5); // или */
			/* заполнение константой с контролем выравнивания */
			if (1&(unsigned long)s) {
				*(uint32_t *)(s-5)=0x20202020U;
				*(s-1)=0x20;
			} else {
				*(s-5)=0x20;
				*(uint32_t *)(s-4)=0x20202020U;
			}
		}
		s++;
	}
FINAL:
	/* достигнут конец строки, вместо \0 заталкиваем в регистр ' ' и проводим финальную проверку
	   при совпадении можно отметить конец строки перед " debug" 
	*/
	acc=(acc|' ')<<8;
	if (acc==the_debug) {
		/* исключительный случай "debug" - иногда выгоднее переносить ret чем размечать конец
		   можно оставить *(s-5)=0 - тогда могут возникать пустые строки " " в ответе 
		*/
		if (ret+5==s) ret=s;
		else *(s-6)=0;
	}
	return ret;
}
char *
undebugit2_wrapper(char *s,char *ignored) {
	return (char *)undebugit2((uint8_t *)s);
}

